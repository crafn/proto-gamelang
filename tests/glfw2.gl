// Compiling: ./compiler ./tests/glfw2.gl -lglfw -lGL

// GLFW
let GLFW_WINDOW : int = 0x00010001;
extern {
	let glfwInit : fn() -> int;
	let glfwTerminate : fn();
	let glfwOpenWindow : fn(w: int, h: int, r: int, g: int, b: int, a: int,
							d: int, s: int, mode: int) -> ?void;
	let glfwSetWindowTitle : fn(str: ?char);
	let glfwSwapBuffers : fn();
	let glfwSleep : fn(seconds: f32);
}

// OpenGL
let GL_COLOR_BUFFER_BIT : int = 16384;
extern {
	let glClearColor : fn(r: f32, g: f32, b: f32, a: f32);
	let glClear : fn(bits : int);
}

// libc
extern {
	/// @todo i64 -> size_t
	let malloc: fn(size: i64) -> ?void;
	let free: fn(ptr: ?void);
}

let Vec2 := tpl[V: struct] -> struct
{
	var x: V = 0;
	var y: V = 0;
};

let Vec2i := Vec2[int];

let Array := tpl[T: struct] -> struct
{
	var size: int = 0;
	var data: ?T = null;
} ~ {
	free(data);
};

/// @todo for-loop
/// @todo fix deref binding power
let push := tpl[U: struct] -> fn(vec: ^Array[U], elem: U)
{
	// Naive implementation
	var new_data : ^U = malloc(sizeof(U)*(vec->size + 1));
	var i : int = 0;
	loop {
		if (i >= vec->size)
			{ break; }
		new_data[i]= vec->data[i];
		i += 1;
	}
	new_data[vec->size] = elem;

	free(vec->data);
	vec->data = new_data;
	vec->size = vec->size + 1;
};

let main := fn() -> int
{
	if (glfwInit() == 0)
		{ return 1; }

	glfwOpenWindow(400, 300, 0,0,0,0,0,0, GLFW_WINDOW);
	glfwSetWindowTitle("gamelang");

	var v := Vec2[int](.x= 10, .y= 20);
	var v2 := Vec2i(.x= 1);

	var vec := Array[Vec2i]();
	push('vec, v);
	'vec.>push(v);

	glClearColor(0.5, 0.5, 0.3, 0.0);
	loop {
		glClear(GL_COLOR_BUFFER_BIT);
		glfwSwapBuffers();
		glfwSleep(0.001);
	};

	glfwTerminate();
	return 0;
};

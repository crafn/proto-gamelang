// Compiling: ./compiler ./tests/glfw2.gl -lglfw -lGL

// GLFW
let GLFW_WINDOW : int = 0x00010001;
extern {
	let glfwInit : fn() -> int;
	let glfwTerminate : fn();
	let glfwOpenWindow : fn(w: int, h: int, r: int, g: int, b: int, a: int,
							d: int, s: int, mode: int) -> ?void;
	let glfwSetWindowTitle : fn(str: ?char);
	let glfwSwapBuffers : fn();
	let glfwSleep : fn(seconds: float);
}

// OpenGL
let GL_COLOR_BUFFER_BIT : int = 16384;
extern {
	let glClearColor : fn(r: float, g: float, b: float, a: float);
	let glClear : fn(bits : int);
}

// libc
extern {
	/// @todo int64 -> size_t
	let malloc: fn(size: int64) -> ?void;
	let free: fn(ptr: ?void);
}

let Vector := tpl[T: struct] -> struct
{
	var size: int = 0;
	var data: ?T = null;
} ~ {
	free(data);
};

/// @todo fix deref binding power
/// @todo Proper name lookup
/// @todo Template argument deduction
/// @todo ++, <=, >= operators
/// @todo for-loop
let push := tpl[U: struct] -> fn(vec: ^Vector[U], elem: U)
{
	// Naive implementation
	var new_data : ^U = malloc(sizeof(U)*(vec->size + 1));
	var i : int = 0;
	loop {
		if (i + 1 > vec->size)
			{ break; }
		new_data[i]= vec->data[i];
		i = i + 1;
	}
	new_data[vec->size] = elem;

	free(vec->data);
	vec->data = new_data;
	vec->size = vec->size + 1;
};

let main := fn() -> int
{
	if (glfwInit() == 0)
		{ return 1; }

	glfwOpenWindow(400, 300, 0,0,0,0,0,0, GLFW_WINDOW);
	glfwSetWindowTitle("gamelang");

	var vec := Vector[int]();
	vec.(push[int])(10);
	vec.(push[int])(16);

	glClearColor(0.5, 0.5, 0.3, 0.0);
	loop {
		glClear(GL_COLOR_BUFFER_BIT);
		glfwSwapBuffers();
		glfwSleep(0.001);
	};

	glfwTerminate();
	return 0;
};

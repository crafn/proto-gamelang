// Compiling: ./compiler ./tests/glfw2.gl -lglfw -lGL

// GLFW
let GLFW_WINDOW := 0x00010001;
let GLFW_KEY_A := 65;
let GLFW_KEY_D := 68;
extern {
	let glfwInit: fn() -> int;
	let glfwTerminate: fn();
	let glfwOpenWindow: fn(	w: int, h: int, r: int, g: int, b: int, a: int,
							d: int, s: int, mode: int) -> ?void;
	let glfwSetWindowTitle: fn(str: ?char);
	let glfwSwapBuffers: fn();
	let glfwSleep: fn(seconds: f32);
	let glfwGetKey: fn(key: int) -> int;
}

// OpenGL
let GL_COLOR_BUFFER_BIT := 16384;
let GL_QUADS := 7;
extern {
	let glClearColor: fn(r: f32, g: f32, b: f32, a: f32);
	let glClear: fn(bits : int);
	let glBegin: fn(mode : int);
	let glEnd: fn();
	let glVertex2f: fn(x: f32, y: f32);
	let glLoadIdentity: fn();
}


// libc
extern {
	/// @todo i64 -> size_t
	let malloc: fn(size: i64) -> ?void;
	let free: fn(ptr: ?void);
}

let Vec2 := tpl[V: struct] -> struct
{
	var x: V = 0;
	var y: V = 0;
};

let Vec2i := Vec2[i32];
let Vec2f := Vec2[f32];

let Array := tpl[T: struct] -> struct
{
	var size: int = 0;
	var data: ?T = null;
} ~ {
	free(data);
};

let push := tpl[U: struct] -> fn(vec: ^Array[U], elem: U)
{
	// Naive implementation
	var new_data : ^U = malloc(sizeof(U)*(vec->size + 1));
	var i := 0;
	loop {
		if (i >= vec->size)
			{ break; }
		new_data[i]= vec->data[i];
		i += 1;
	}
	new_data[vec->size] = elem;

	free(vec->data);
	vec->data = new_data;
	vec->size += 1;
};

let drawQuad := fn(pos: Vec2f, rad: Vec2f)
{
	var ll := Vec2f(pos.x - rad.x, pos.y - rad.y);
	var ur := Vec2f(pos.x + rad.x, pos.y + rad.y);
	glBegin(GL_QUADS);
		glVertex2f(ll.x, ll.y);
		glVertex2f(ur.x, ll.y);
		glVertex2f(ur.x, ur.y);
		glVertex2f(ll.x, ur.y);
	glEnd();
};

let GameState := struct
{
	var playerPos := Vec2f(0.0, 0.0);
};

let update := fn(game: ^GameState)
{
	game->playerPos.x += 0.01;
};

let render := fn(game: ^GameState)
{
	glClearColor(0.5, 0.5, 0.3, 0.0);
	glClear(GL_COLOR_BUFFER_BIT);

	glLoadIdentity();
	drawQuad(game->playerPos, Vec2f(0.3, 0.3));

	glfwSwapBuffers();
};

let main := fn() -> int
{
	if (glfwInit() == 0)
		{ return 1; }

	glfwOpenWindow(600, 600, 0,0,0,0,0,0, GLFW_WINDOW);
	glfwSetWindowTitle("gamelang");

	var game := GameState();
	loop {
		update('game);
		render('game);
		glfwSleep(0.001);
	};

	glfwTerminate();
	return 0;
};
